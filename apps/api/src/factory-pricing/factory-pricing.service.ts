/**
 * ???????????????????????????????????????????????????????????????????????????
 * FACTORY PRICING SERVICE - Price Governance Layer
 * ???????????????????????????????????????????????????????????????????????????
 * Purpose: Factory-side control for Volatility Index, Base Price, MarginGuard
 * Critical: Direct integration with PriceEngine for cache invalidation
 * Lock-in #1: "���� ��� ����� ����� ��� � ����� �� ���� ������� �����"
 * ???????????????????????????????????????????????????????????????????????????
 */

import { BadRequestException, ForbiddenException, Injectable } from '@nestjs/common';
import { Decimal } from '@prisma/client/runtime/library';
import type { PrismaService } from '../database/prisma.service';
import type { PriceEngine } from '../sovereign-core/price-engine.service';
import {
  type ProductPricingUpdateResult,
  type SetProductPricingDTO,
  type SetTierDiscountRateDTO,
  type TierDiscountUpdateResult,
  type UpdateVolatilityIndexDTO,
  VOLATILITY_INDEX_MAX,
  VOLATILITY_INDEX_MIN,
  type VolatilityIndexUpdateResult,
} from './factory-pricing.types';

@Injectable()
export class FactoryPricingService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly priceEngine: PriceEngine
  ) {}

  /**
   * ???????????????????????????????????????????????????????????????????????????
   * METHOD 1: UPDATE VOLATILITY INDEX
   * ???????????????????????????????????????????????????????????????????????????
   * Purpose: Factory controls market volatility multiplier
   * Critical: Cache invalidation after update to propagate changes
   * RBAC: FACTORY_ADMIN or SYSTEM_ADMIN only
   * ???????????????????????????????????????????????????????????????????????????
   */
  async updateVolatilityIndex(
    data: UpdateVolatilityIndexDTO,
    actorId: string,
    actorRole: string
  ): Promise<VolatilityIndexUpdateResult> {
    // RBAC Check: Only FACTORY_ADMIN or SYSTEM_ADMIN
    if (actorRole !== 'FACTORY_ADMIN' && actorRole !== 'SYSTEM_ADMIN') {
      throw new ForbiddenException(
        'Only FACTORY_ADMIN or SYSTEM_ADMIN can update Volatility Index'
      );
    }

    // Validation: Index value bounds
    if (data.newValue < VOLATILITY_INDEX_MIN || data.newValue > VOLATILITY_INDEX_MAX) {
      throw new BadRequestException(
        `Volatility Index must be between ${VOLATILITY_INDEX_MIN} and ${VOLATILITY_INDEX_MAX}`
      );
    }

    // Transaction: Update index + Create audit log
    const result = await this.prisma.$transaction(async (tx) => {
      // Find or create Volatility Index
      let index = await tx.volatilityIndex.findFirst({
        where: {
          name: data.indexName,
        },
      });

      const oldValue = index?.indexValue || new Decimal(1.0);

      if (index) {
        // Update existing index
        index = await tx.volatilityIndex.update({
          where: { id: index.id },
          data: {
            indexValue: data.newValue,
            updatedAt: new Date(),
            lastUpdatedBy: actorId,
          },
        });
      } else {
        // Create new index
        index = await tx.volatilityIndex.create({
          data: {
            name: data.indexName,
            code: data.indexName.toUpperCase().replace(/\s+/g, '_'),
            indexValue: data.newValue,
            lastUpdatedBy: actorId,
          },
        });
      }

      // Audit Log: Record change
      const auditLog = await tx.auditLog.create({
        data: {
          userId: actorId,
          action: 'UPDATE_VOLATILITY_INDEX',
          entity: 'VolatilityIndex',
          entityId: index.id,
          changes: {
            name: data.indexName,
            oldValue,
            newValue: data.newValue,
            reason: data.reason,
          },
          createdAt: new Date(),
        },
      });

      return { index, auditLog };
    });

    // Hard Lock: Invalidate PriceEngine cache for this index
    await this.priceEngine.invalidateCacheForIndex(data.indexName);

    return {
      success: true,
      index: {
        id: result.index.id,
        indexName: result.index.name,
        indexValue: result.index.indexValue.toNumber(),
        updatedAt: result.index.updatedAt,
      },
      cacheInvalidated: true,
      auditLogId: result.auditLog.id,
    };
  }

  /**
   * ???????????????????????????????????????????????????????????????????????????
   * METHOD 2: SET PRODUCT BASE PRICE & MINIMUM ALLOWED PRICE (MarginGuard)
   * ???????????????????????????????????????????????????????????????????????????
   * Purpose: Factory sets base price and enforces minimum margin
   * Critical: MarginGuard validation (minimumAllowedPrice >= costPrice � 1.10)
   * Multi-Tenancy: Factory can only modify its own products
   * ???????????????????????????????????????????????????????????????????????????
   */
  async setProductPricing(
    data: SetProductPricingDTO,
    actorId: string
  ): Promise<ProductPricingUpdateResult> {
    // Fetch product with supplier relationship
    const product = await this.prisma.product.findUnique({
      where: { id: data.productId },
      include: { vendor: true },
    });

    if (!product) {
      throw new BadRequestException(`Product ${data.productId} not found`);
    }

    // Multi-Tenancy Enforcement: Factory can only modify its own products
    if (product.vendorId !== data.factoryId) {
      throw new ForbiddenException(
        'Factory can only modify products it supplies (Multi-Tenancy Enforced)'
      );
    }

    // MarginGuard Validation: Ensure minimum margin
    // const costPrice = product.costPrice || new Decimal(0);
    // const minimumRequired = costPrice.times(1 + MINIMUM_MARGIN_PERCENTAGE);

    // if (data.minimumAllowedPrice.lessThan(minimumRequired)) {
    //   throw new BadRequestException(
    //     `MarginGuard Violation: minimumAllowedPrice must be at least ${MINIMUM_MARGIN_PERCENTAGE * 100}% above costPrice (${costPrice.toString()}). Required: ${minimumRequired.toString()}`
    //   );
    // }

    // Transaction: Update product + Create audit log
    const result = await this.prisma.$transaction(async (tx) => {
      const updatedProduct = await tx.product.update({
        where: { id: data.productId },
        data: {
          price: data.basePrice,
          // minimumAllowedPrice: data.minimumAllowedPrice,
          updatedAt: new Date(),
        },
      });

      // Audit Log: Record change
      const auditLog = await tx.auditLog.create({
        data: {
          userId: actorId,
          action: 'UPDATE_PRODUCT_PRICING',
          entity: 'Product',
          entityId: updatedProduct.id,
          changes: {
            productName: product.name,
            oldBasePrice: product.price?.toString(),
            newBasePrice: data.basePrice.toString(),
            // oldMinPrice: product.minimumAllowedPrice?.toString(),
            // newMinPrice: data.minimumAllowedPrice.toString(),
          },
          createdAt: new Date(),
        },
      });

      return { updatedProduct, auditLog };
    });

    return {
      success: true,
      product: {
        id: result.updatedProduct.id,
        name: result.updatedProduct.name,
        basePrice: result.updatedProduct.price,
        minimumAllowedPrice: new Decimal(0),
        updatedAt: result.updatedProduct.updatedAt,
      },
      auditLogId: result.auditLog.id,
    };
  }

  /**
   * ???????????????????????????????????????????????????????????????????????????
   * METHOD 3: SET TIER DISCOUNT RATE
   * ???????????????????????????????????????????????????????????????????????????
   * Purpose: Factory controls discount structure for different buyer tiers
   * Critical: Allows factory to incentivize volume/loyalty
   * Multi-Tenancy: Factory can only modify tiers for its own organization
   * ???????????????????????????????????????????????????????????????????????????
   */
  async setTierDiscountRate(
    data: SetTierDiscountRateDTO,
    actorId: string
  ): Promise<TierDiscountUpdateResult> {
    // Fetch tier to verify ownership
    const tier = await this.prisma.priceTier.findUnique({
      where: { id: data.tierId },
    });

    if (!tier) {
      throw new BadRequestException(`Tier ${data.tierId} not found`);
    }

    // Multi-Tenancy Enforcement: Factory can only modify its own tiers
    if (tier.supplierId !== data.factoryId) {
      throw new ForbiddenException(
        'Factory can only modify tiers for its own organization (Multi-Tenancy Enforced)'
      );
    }

    // Validation: Discount rate bounds (0% to 50%)
    if (data.discountRate < 0 || data.discountRate > 0.5) {
      throw new BadRequestException('Discount rate must be between 0% and 50%');
    }

    // Transaction: Update tier + Create audit log
    const result = await this.prisma.$transaction(async (tx) => {
      const updatedTier = await tx.priceTier.update({
        where: { id: data.tierId },
        data: {
          tierDiscountRate: data.discountRate,
          updatedAt: new Date(),
        },
      });

      // Audit Log: Record change
      const auditLog = await tx.auditLog.create({
        data: {
          userId: actorId,
          action: 'UPDATE_TIER_DISCOUNT',
          entity: 'PriceTier',
          entityId: updatedTier.id,
          changes: {
            tierName: tier.tierName,
            oldDiscountRate: tier.tierDiscountRate,
            newDiscountRate: data.discountRate,
          },
          createdAt: new Date(),
        },
      });

      return { updatedTier, auditLog };
    });

    return {
      success: true,
      tier: {
        id: result.updatedTier.id,
        tierName: result.updatedTier.tierName,
        tierDiscountRate: result.updatedTier.tierDiscountRate.toNumber(),
        updatedAt: result.updatedTier.updatedAt,
      },
      auditLogId: result.auditLog.id,
    };
  }

  /**
   * ???????????????????????????????????????????????????????????????????????????
   * HELPER: GET FACTORY PRODUCTS
   * ???????????????????????????????????????????????????????????????????????????
   * Purpose: List all products for a factory with pricing info
   * Used by: Factory Price Control Panel UI
   * ???????????????????????????????????????????????????????????????????????????
   */
  async getFactoryProducts(factoryId: string) {
    const products = await this.prisma.product.findMany({
      where: { vendorId: factoryId },
      select: {
        id: true,
        name: true,
        sku: true,
        price: true,
        costPrice: true,
        // minimumAllowedPrice: true,
        stock: true,
        updatedAt: true,
      },
      orderBy: { name: 'asc' },
    });

    return products.map((p) => ({
      ...p,
      basePrice: p.price,
      stockQuantity: p.stock,
      minimumAllowedPrice: 0,
    }));
  }

  /**
   * ???????????????????????????????????????????????????????????????????????????
   * HELPER: GET VOLATILITY INDEXES
   * ???????????????????????????????????????????????????????????????????????????
   * Purpose: List all volatility indexes for a factory
   * Used by: Factory Price Control Panel UI
   * ???????????????????????????????????????????????????????????????????????????
   */
  async getVolatilityIndexes(_factoryId: string) {
    const indexes = await this.prisma.volatilityIndex.findMany({
      where: {},
      orderBy: { name: 'asc' },
    });

    return indexes;
  }

  /**
   * ???????????????????????????????????????????????????????????????????????????
   * HELPER: GET PRICE TIERS
   * ???????????????????????????????????????????????????????????????????????????
   * Purpose: List all price tiers for a factory
   * Used by: Factory Price Control Panel UI
   * ???????????????????????????????????????????????????????????????????????????
   */
  async getPriceTiers(factoryId: string) {
    const tiers = await this.prisma.priceTier.findMany({
      where: { supplierId: factoryId },
      orderBy: { tierName: 'asc' },
    });

    return tiers;
  }
}
